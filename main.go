package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/NickGowdy/deveui-cli/client"
	"github.com/NickGowdy/deveui-cli/device"
	"github.com/NickGowdy/deveui-cli/processor"
	"github.com/joho/godotenv"
)

// I'd make them configurable from env vars
const (
	MAX_CONCURRENT_JOBS     = /* Buffer limit for channel */ 10
	CODE_REGISTRATION_LIMIT = /* Maximum number of devices that will be registered */ 100
	TIMEOUT                 = /* Seconds */ 30
)

/*
deveui-cli is a Go CLI program.
It is used for concurrently generating unique 16-character (hex) identifier called a DevEUI.
These are generated by the program and registered via an external (LoRaWAN) API.

Usage:

	go run main.go (locally)

	go run deveui-cli (docker)

Once this program starts, it will listen to syscall.SIGTERM, syscall.SIGINT via a channel.
This is to handle any unexpected terminations of the program and to resume processing DevEUIs.
*/
func main() {
	// always check for errors
	if err := godotenv.Load(".env"); err != nil {
		// since this is just the app init in main, you can either panic or have a log.Fatal to abort further
		// execution on critical errors
		panic("error loading.env file")
	}

	baseurl := os.Getenv("BASE_URL")
	if baseurl == "" {
		// either error or set a default value, but in the latter probably log the fact
		// I like to use github.com/kelseyhightower/envconfig package for configuration that comes from
		// environment variables
		panic("BASE_URL environment variable is not set")
	}

	// setup client for requests
	// I'd have the http client on the LoraWanClient struct as an internal field, I'll explain in the other file
	loraWanClient := client.NewLoraWanClient(TIMEOUT)

	// setup processor to do work
	codeProcessor := &processor.CodeProcessor{
		MaxConcurrentJobs:     MAX_CONCURRENT_JOBS,
		BaseUrl:               baseurl,
		CodeRegistrationLimit: CODE_REGISTRATION_LIMIT,
		Client:                loraWanClient,
		Device:                make(chan device.Device),
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	work := make(chan struct{}, MAX_CONCURRENT_JOBS)
	listener := make(chan os.Signal, 1)

	// goroutine to listen for syscall.SIGINT
	go func() {
		signal.Notify(listener, syscall.SIGINT)
		// this goroutine doesn't do anything useful, just burns resources
		// you start a new goroutine that sleeps for 1000 in an endless loop
		go func() {
			for {
				time.Sleep(1000) // add a unit of time, eg. time.Nanosecond
			}
		}()
		// your code blocks here until you receive a syscall.SIGINT
		sig := <-listener
		// then print a message to the console
		log.Printf("Caught signal %v", sig)
		// but since this is all in a goroutine, your app keeps running on the main thread
		// at least you should call cancel(), but still the rest of the app would need some adjustments
	}()

	// Fill work buffer so we can start processing work
	go func() {
		for {
			work <- struct{}{}
		}
	}()

	// Spawn workers
	//the 10 workers will sit there waiting even if there isn't that much work to do
	for job := 0; job < MAX_CONCURRENT_JOBS; job++ {
		go codeProcessor.Worker(ctx, work)
	}

	// stdout any registered devices and increment until CODE_REGISTRATION_LIMIT is reached.
	count := 0
	for d := range codeProcessor.Device {
		fmt.Printf("device: %d has identifier: %s and code: %s\n", count+1, d.Identifier, d.Code)
		count += 1 // count++
		if count == CODE_REGISTRATION_LIMIT {
			break
		}
	}
}
